// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 01 May 2019 16:47:00 MSK.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vorbis

/*
#cgo pkg-config: ogg vorbis vorbisenc
#include "ogg/ogg.h"
#include "vorbis/codec.h"
#include "vorbis/vorbisenc.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocOggIovecMemory allocates memory for type C.ogg_iovec_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOggIovecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOggIovecValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOggIovecValue = unsafe.Sizeof([1]C.ogg_iovec_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OggIovec) Ref() *C.ogg_iovec_t {
	if x == nil {
		return nil
	}
	return x.ref92a8e63c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OggIovec) Free() {
	if x != nil && x.allocs92a8e63c != nil {
		x.allocs92a8e63c.(*cgoAllocMap).Free()
		x.ref92a8e63c = nil
	}
}

// NewOggIovecRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOggIovecRef(ref unsafe.Pointer) *OggIovec {
	if ref == nil {
		return nil
	}
	obj := new(OggIovec)
	obj.ref92a8e63c = (*C.ogg_iovec_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OggIovec) PassRef() (*C.ogg_iovec_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref92a8e63c != nil {
		return x.ref92a8e63c, nil
	}
	mem92a8e63c := allocOggIovecMemory(1)
	ref92a8e63c := (*C.ogg_iovec_t)(mem92a8e63c)
	allocs92a8e63c := new(cgoAllocMap)
	allocs92a8e63c.Add(mem92a8e63c)

	var ciov_base_allocs *cgoAllocMap
	ref92a8e63c.iov_base, ciov_base_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.IovBase)), cgoAllocsUnknown
	allocs92a8e63c.Borrow(ciov_base_allocs)

	var ciov_len_allocs *cgoAllocMap
	ref92a8e63c.iov_len, ciov_len_allocs = (C.size_t)(x.IovLen), cgoAllocsUnknown
	allocs92a8e63c.Borrow(ciov_len_allocs)

	x.ref92a8e63c = ref92a8e63c
	x.allocs92a8e63c = allocs92a8e63c
	return ref92a8e63c, allocs92a8e63c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OggIovec) PassValue() (C.ogg_iovec_t, *cgoAllocMap) {
	if x.ref92a8e63c != nil {
		return *x.ref92a8e63c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OggIovec) Deref() {
	if x.ref92a8e63c == nil {
		return
	}
	x.IovBase = (unsafe.Pointer)(unsafe.Pointer(x.ref92a8e63c.iov_base))
	x.IovLen = (uint)(x.ref92a8e63c.iov_len)
}

// allocOggPageMemory allocates memory for type C.ogg_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOggPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOggPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOggPageValue = unsafe.Sizeof([1]C.ogg_page{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OggPage) Ref() *C.ogg_page {
	if x == nil {
		return nil
	}
	return x.refb80411d1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OggPage) Free() {
	if x != nil && x.allocsb80411d1 != nil {
		x.allocsb80411d1.(*cgoAllocMap).Free()
		x.refb80411d1 = nil
	}
}

// NewOggPageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOggPageRef(ref unsafe.Pointer) *OggPage {
	if ref == nil {
		return nil
	}
	obj := new(OggPage)
	obj.refb80411d1 = (*C.ogg_page)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OggPage) PassRef() (*C.ogg_page, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb80411d1 != nil {
		return x.refb80411d1, nil
	}
	memb80411d1 := allocOggPageMemory(1)
	refb80411d1 := (*C.ogg_page)(memb80411d1)
	allocsb80411d1 := new(cgoAllocMap)
	allocsb80411d1.Add(memb80411d1)

	var cheader_allocs *cgoAllocMap
	refb80411d1.header, cheader_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Header)).Data)), cgoAllocsUnknown
	allocsb80411d1.Borrow(cheader_allocs)

	var cheader_len_allocs *cgoAllocMap
	refb80411d1.header_len, cheader_len_allocs = (C.long)(x.HeaderLen), cgoAllocsUnknown
	allocsb80411d1.Borrow(cheader_len_allocs)

	var cbody_allocs *cgoAllocMap
	refb80411d1.body, cbody_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Body)).Data)), cgoAllocsUnknown
	allocsb80411d1.Borrow(cbody_allocs)

	var cbody_len_allocs *cgoAllocMap
	refb80411d1.body_len, cbody_len_allocs = (C.long)(x.BodyLen), cgoAllocsUnknown
	allocsb80411d1.Borrow(cbody_len_allocs)

	x.refb80411d1 = refb80411d1
	x.allocsb80411d1 = allocsb80411d1
	return refb80411d1, allocsb80411d1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OggPage) PassValue() (C.ogg_page, *cgoAllocMap) {
	if x.refb80411d1 != nil {
		return *x.refb80411d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OggPage) Deref() {
	if x.refb80411d1 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Header))
	hxfc4425b.Data = unsafe.Pointer(x.refb80411d1.header)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.HeaderLen = (int)(x.refb80411d1.header_len)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Body))
	hxf95e7c8.Data = unsafe.Pointer(x.refb80411d1.body)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.BodyLen = (int)(x.refb80411d1.body_len)
}

// allocOggStreamStateMemory allocates memory for type C.ogg_stream_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOggStreamStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOggStreamStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOggStreamStateValue = unsafe.Sizeof([1]C.ogg_stream_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OggStreamState) Ref() *C.ogg_stream_state {
	if x == nil {
		return nil
	}
	return x.refd2ebdd43
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OggStreamState) Free() {
	if x != nil && x.allocsd2ebdd43 != nil {
		x.allocsd2ebdd43.(*cgoAllocMap).Free()
		x.refd2ebdd43 = nil
	}
}

// NewOggStreamStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOggStreamStateRef(ref unsafe.Pointer) *OggStreamState {
	if ref == nil {
		return nil
	}
	obj := new(OggStreamState)
	obj.refd2ebdd43 = (*C.ogg_stream_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OggStreamState) PassRef() (*C.ogg_stream_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd2ebdd43 != nil {
		return x.refd2ebdd43, nil
	}
	memd2ebdd43 := allocOggStreamStateMemory(1)
	refd2ebdd43 := (*C.ogg_stream_state)(memd2ebdd43)
	allocsd2ebdd43 := new(cgoAllocMap)
	allocsd2ebdd43.Add(memd2ebdd43)

	var cbody_data_allocs *cgoAllocMap
	refd2ebdd43.body_data, cbody_data_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.BodyData)).Data)), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cbody_data_allocs)

	var cbody_storage_allocs *cgoAllocMap
	refd2ebdd43.body_storage, cbody_storage_allocs = (C.long)(x.BodyStorage), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cbody_storage_allocs)

	var cbody_fill_allocs *cgoAllocMap
	refd2ebdd43.body_fill, cbody_fill_allocs = (C.long)(x.BodyFill), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cbody_fill_allocs)

	var cbody_returned_allocs *cgoAllocMap
	refd2ebdd43.body_returned, cbody_returned_allocs = (C.long)(x.BodyReturned), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cbody_returned_allocs)

	var clacing_vals_allocs *cgoAllocMap
	refd2ebdd43.lacing_vals, clacing_vals_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.LacingVals)).Data)), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(clacing_vals_allocs)

	var cgranule_vals_allocs *cgoAllocMap
	refd2ebdd43.granule_vals, cgranule_vals_allocs = (*C.ogg_int64_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.GranuleVals)).Data)), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cgranule_vals_allocs)

	var clacing_storage_allocs *cgoAllocMap
	refd2ebdd43.lacing_storage, clacing_storage_allocs = (C.long)(x.LacingStorage), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(clacing_storage_allocs)

	var clacing_fill_allocs *cgoAllocMap
	refd2ebdd43.lacing_fill, clacing_fill_allocs = (C.long)(x.LacingFill), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(clacing_fill_allocs)

	var clacing_packet_allocs *cgoAllocMap
	refd2ebdd43.lacing_packet, clacing_packet_allocs = (C.long)(x.LacingPacket), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(clacing_packet_allocs)

	var clacing_returned_allocs *cgoAllocMap
	refd2ebdd43.lacing_returned, clacing_returned_allocs = (C.long)(x.LacingReturned), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(clacing_returned_allocs)

	var cheader_allocs *cgoAllocMap
	refd2ebdd43.header, cheader_allocs = *(*[282]C.uchar)(unsafe.Pointer(&x.Header)), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cheader_allocs)

	var cheader_fill_allocs *cgoAllocMap
	refd2ebdd43.header_fill, cheader_fill_allocs = (C.int)(x.HeaderFill), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cheader_fill_allocs)

	var ce_o_s_allocs *cgoAllocMap
	refd2ebdd43.e_o_s, ce_o_s_allocs = (C.int)(x.EOS), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(ce_o_s_allocs)

	var cb_o_s_allocs *cgoAllocMap
	refd2ebdd43.b_o_s, cb_o_s_allocs = (C.int)(x.BOS), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cb_o_s_allocs)

	var cserialno_allocs *cgoAllocMap
	refd2ebdd43.serialno, cserialno_allocs = (C.long)(x.Serialno), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cserialno_allocs)

	var cpageno_allocs *cgoAllocMap
	refd2ebdd43.pageno, cpageno_allocs = (C.long)(x.Pageno), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cpageno_allocs)

	var cpacketno_allocs *cgoAllocMap
	refd2ebdd43.packetno, cpacketno_allocs = (C.ogg_int64_t)(x.Packetno), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cpacketno_allocs)

	var cgranulepos_allocs *cgoAllocMap
	refd2ebdd43.granulepos, cgranulepos_allocs = (C.ogg_int64_t)(x.Granulepos), cgoAllocsUnknown
	allocsd2ebdd43.Borrow(cgranulepos_allocs)

	x.refd2ebdd43 = refd2ebdd43
	x.allocsd2ebdd43 = allocsd2ebdd43
	return refd2ebdd43, allocsd2ebdd43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OggStreamState) PassValue() (C.ogg_stream_state, *cgoAllocMap) {
	if x.refd2ebdd43 != nil {
		return *x.refd2ebdd43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OggStreamState) Deref() {
	if x.refd2ebdd43 == nil {
		return
	}
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.BodyData))
	hxff2234b.Data = unsafe.Pointer(x.refd2ebdd43.body_data)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.BodyStorage = (int)(x.refd2ebdd43.body_storage)
	x.BodyFill = (int)(x.refd2ebdd43.body_fill)
	x.BodyReturned = (int)(x.refd2ebdd43.body_returned)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.LacingVals))
	hxff73280.Data = unsafe.Pointer(x.refd2ebdd43.lacing_vals)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.GranuleVals))
	hxfa9955c.Data = unsafe.Pointer(x.refd2ebdd43.granule_vals)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	x.LacingStorage = (int)(x.refd2ebdd43.lacing_storage)
	x.LacingFill = (int)(x.refd2ebdd43.lacing_fill)
	x.LacingPacket = (int)(x.refd2ebdd43.lacing_packet)
	x.LacingReturned = (int)(x.refd2ebdd43.lacing_returned)
	x.Header = *(*[282]byte)(unsafe.Pointer(&x.refd2ebdd43.header))
	x.HeaderFill = (int32)(x.refd2ebdd43.header_fill)
	x.EOS = (int32)(x.refd2ebdd43.e_o_s)
	x.BOS = (int32)(x.refd2ebdd43.b_o_s)
	x.Serialno = (int)(x.refd2ebdd43.serialno)
	x.Pageno = (int)(x.refd2ebdd43.pageno)
	x.Packetno = (OggInt64)(x.refd2ebdd43.packetno)
	x.Granulepos = (OggInt64)(x.refd2ebdd43.granulepos)
}

// allocOggPacketMemory allocates memory for type C.ogg_packet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOggPacketMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOggPacketValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOggPacketValue = unsafe.Sizeof([1]C.ogg_packet{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OggPacket) Ref() *C.ogg_packet {
	if x == nil {
		return nil
	}
	return x.ref7954eecd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OggPacket) Free() {
	if x != nil && x.allocs7954eecd != nil {
		x.allocs7954eecd.(*cgoAllocMap).Free()
		x.ref7954eecd = nil
	}
}

// NewOggPacketRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOggPacketRef(ref unsafe.Pointer) *OggPacket {
	if ref == nil {
		return nil
	}
	obj := new(OggPacket)
	obj.ref7954eecd = (*C.ogg_packet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OggPacket) PassRef() (*C.ogg_packet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7954eecd != nil {
		return x.ref7954eecd, nil
	}
	mem7954eecd := allocOggPacketMemory(1)
	ref7954eecd := (*C.ogg_packet)(mem7954eecd)
	allocs7954eecd := new(cgoAllocMap)
	allocs7954eecd.Add(mem7954eecd)

	var cpacket_allocs *cgoAllocMap
	ref7954eecd.packet, cpacket_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Packet)).Data)), cgoAllocsUnknown
	allocs7954eecd.Borrow(cpacket_allocs)

	var cbytes_allocs *cgoAllocMap
	ref7954eecd.bytes, cbytes_allocs = (C.long)(x.Bytes), cgoAllocsUnknown
	allocs7954eecd.Borrow(cbytes_allocs)

	var cb_o_s_allocs *cgoAllocMap
	ref7954eecd.b_o_s, cb_o_s_allocs = (C.long)(x.BOS), cgoAllocsUnknown
	allocs7954eecd.Borrow(cb_o_s_allocs)

	var ce_o_s_allocs *cgoAllocMap
	ref7954eecd.e_o_s, ce_o_s_allocs = (C.long)(x.EOS), cgoAllocsUnknown
	allocs7954eecd.Borrow(ce_o_s_allocs)

	var cgranulepos_allocs *cgoAllocMap
	ref7954eecd.granulepos, cgranulepos_allocs = (C.ogg_int64_t)(x.Granulepos), cgoAllocsUnknown
	allocs7954eecd.Borrow(cgranulepos_allocs)

	var cpacketno_allocs *cgoAllocMap
	ref7954eecd.packetno, cpacketno_allocs = (C.ogg_int64_t)(x.Packetno), cgoAllocsUnknown
	allocs7954eecd.Borrow(cpacketno_allocs)

	x.ref7954eecd = ref7954eecd
	x.allocs7954eecd = allocs7954eecd
	return ref7954eecd, allocs7954eecd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OggPacket) PassValue() (C.ogg_packet, *cgoAllocMap) {
	if x.ref7954eecd != nil {
		return *x.ref7954eecd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OggPacket) Deref() {
	if x.ref7954eecd == nil {
		return
	}
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.Packet))
	hxfa3f05c.Data = unsafe.Pointer(x.ref7954eecd.packet)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.Bytes = (int)(x.ref7954eecd.bytes)
	x.BOS = (int)(x.ref7954eecd.b_o_s)
	x.EOS = (int)(x.ref7954eecd.e_o_s)
	x.Granulepos = (OggInt64)(x.ref7954eecd.granulepos)
	x.Packetno = (OggInt64)(x.ref7954eecd.packetno)
}

// allocOggSyncStateMemory allocates memory for type C.ogg_sync_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOggSyncStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOggSyncStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOggSyncStateValue = unsafe.Sizeof([1]C.ogg_sync_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OggSyncState) Ref() *C.ogg_sync_state {
	if x == nil {
		return nil
	}
	return x.ref69d6025b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OggSyncState) Free() {
	if x != nil && x.allocs69d6025b != nil {
		x.allocs69d6025b.(*cgoAllocMap).Free()
		x.ref69d6025b = nil
	}
}

// NewOggSyncStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOggSyncStateRef(ref unsafe.Pointer) *OggSyncState {
	if ref == nil {
		return nil
	}
	obj := new(OggSyncState)
	obj.ref69d6025b = (*C.ogg_sync_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OggSyncState) PassRef() (*C.ogg_sync_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69d6025b != nil {
		return x.ref69d6025b, nil
	}
	mem69d6025b := allocOggSyncStateMemory(1)
	ref69d6025b := (*C.ogg_sync_state)(mem69d6025b)
	allocs69d6025b := new(cgoAllocMap)
	allocs69d6025b.Add(mem69d6025b)

	var cdata_allocs *cgoAllocMap
	ref69d6025b.data, cdata_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Data)).Data)), cgoAllocsUnknown
	allocs69d6025b.Borrow(cdata_allocs)

	var cstorage_allocs *cgoAllocMap
	ref69d6025b.storage, cstorage_allocs = (C.int)(x.Storage), cgoAllocsUnknown
	allocs69d6025b.Borrow(cstorage_allocs)

	var cfill_allocs *cgoAllocMap
	ref69d6025b.fill, cfill_allocs = (C.int)(x.Fill), cgoAllocsUnknown
	allocs69d6025b.Borrow(cfill_allocs)

	var creturned_allocs *cgoAllocMap
	ref69d6025b.returned, creturned_allocs = (C.int)(x.Returned), cgoAllocsUnknown
	allocs69d6025b.Borrow(creturned_allocs)

	var cunsynced_allocs *cgoAllocMap
	ref69d6025b.unsynced, cunsynced_allocs = (C.int)(x.Unsynced), cgoAllocsUnknown
	allocs69d6025b.Borrow(cunsynced_allocs)

	var cheaderbytes_allocs *cgoAllocMap
	ref69d6025b.headerbytes, cheaderbytes_allocs = (C.int)(x.Headerbytes), cgoAllocsUnknown
	allocs69d6025b.Borrow(cheaderbytes_allocs)

	var cbodybytes_allocs *cgoAllocMap
	ref69d6025b.bodybytes, cbodybytes_allocs = (C.int)(x.Bodybytes), cgoAllocsUnknown
	allocs69d6025b.Borrow(cbodybytes_allocs)

	x.ref69d6025b = ref69d6025b
	x.allocs69d6025b = allocs69d6025b
	return ref69d6025b, allocs69d6025b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OggSyncState) PassValue() (C.ogg_sync_state, *cgoAllocMap) {
	if x.ref69d6025b != nil {
		return *x.ref69d6025b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OggSyncState) Deref() {
	if x.ref69d6025b == nil {
		return
	}
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxf0d18b7.Data = unsafe.Pointer(x.ref69d6025b.data)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

	x.Storage = (int32)(x.ref69d6025b.storage)
	x.Fill = (int32)(x.ref69d6025b.fill)
	x.Returned = (int32)(x.ref69d6025b.returned)
	x.Unsynced = (int32)(x.ref69d6025b.unsynced)
	x.Headerbytes = (int32)(x.ref69d6025b.headerbytes)
	x.Bodybytes = (int32)(x.ref69d6025b.bodybytes)
}

// allocInfoMemory allocates memory for type C.vorbis_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInfoValue = unsafe.Sizeof([1]C.vorbis_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Info) Ref() *C.vorbis_info {
	if x == nil {
		return nil
	}
	return x.refd271fa3c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Info) Free() {
	if x != nil && x.allocsd271fa3c != nil {
		x.allocsd271fa3c.(*cgoAllocMap).Free()
		x.refd271fa3c = nil
	}
}

// NewInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInfoRef(ref unsafe.Pointer) *Info {
	if ref == nil {
		return nil
	}
	obj := new(Info)
	obj.refd271fa3c = (*C.vorbis_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Info) PassRef() (*C.vorbis_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd271fa3c != nil {
		return x.refd271fa3c, nil
	}
	memd271fa3c := allocInfoMemory(1)
	refd271fa3c := (*C.vorbis_info)(memd271fa3c)
	allocsd271fa3c := new(cgoAllocMap)
	allocsd271fa3c.Add(memd271fa3c)

	var cversion_allocs *cgoAllocMap
	refd271fa3c.version, cversion_allocs = (C.int)(x.Version), cgoAllocsUnknown
	allocsd271fa3c.Borrow(cversion_allocs)

	var cchannels_allocs *cgoAllocMap
	refd271fa3c.channels, cchannels_allocs = (C.int)(x.Channels), cgoAllocsUnknown
	allocsd271fa3c.Borrow(cchannels_allocs)

	var crate_allocs *cgoAllocMap
	refd271fa3c.rate, crate_allocs = (C.long)(x.Rate), cgoAllocsUnknown
	allocsd271fa3c.Borrow(crate_allocs)

	var cbitrate_upper_allocs *cgoAllocMap
	refd271fa3c.bitrate_upper, cbitrate_upper_allocs = (C.long)(x.BitrateUpper), cgoAllocsUnknown
	allocsd271fa3c.Borrow(cbitrate_upper_allocs)

	var cbitrate_nominal_allocs *cgoAllocMap
	refd271fa3c.bitrate_nominal, cbitrate_nominal_allocs = (C.long)(x.BitrateNominal), cgoAllocsUnknown
	allocsd271fa3c.Borrow(cbitrate_nominal_allocs)

	var cbitrate_lower_allocs *cgoAllocMap
	refd271fa3c.bitrate_lower, cbitrate_lower_allocs = (C.long)(x.BitrateLower), cgoAllocsUnknown
	allocsd271fa3c.Borrow(cbitrate_lower_allocs)

	var cbitrate_window_allocs *cgoAllocMap
	refd271fa3c.bitrate_window, cbitrate_window_allocs = (C.long)(x.BitrateWindow), cgoAllocsUnknown
	allocsd271fa3c.Borrow(cbitrate_window_allocs)

	var ccodec_setup_allocs *cgoAllocMap
	refd271fa3c.codec_setup, ccodec_setup_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.CodecSetup)), cgoAllocsUnknown
	allocsd271fa3c.Borrow(ccodec_setup_allocs)

	x.refd271fa3c = refd271fa3c
	x.allocsd271fa3c = allocsd271fa3c
	return refd271fa3c, allocsd271fa3c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Info) PassValue() (C.vorbis_info, *cgoAllocMap) {
	if x.refd271fa3c != nil {
		return *x.refd271fa3c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Info) Deref() {
	if x.refd271fa3c == nil {
		return
	}
	x.Version = (int32)(x.refd271fa3c.version)
	x.Channels = (int32)(x.refd271fa3c.channels)
	x.Rate = (int)(x.refd271fa3c.rate)
	x.BitrateUpper = (int)(x.refd271fa3c.bitrate_upper)
	x.BitrateNominal = (int)(x.refd271fa3c.bitrate_nominal)
	x.BitrateLower = (int)(x.refd271fa3c.bitrate_lower)
	x.BitrateWindow = (int)(x.refd271fa3c.bitrate_window)
	x.CodecSetup = (unsafe.Pointer)(unsafe.Pointer(x.refd271fa3c.codec_setup))
}

// allocDspStateMemory allocates memory for type C.vorbis_dsp_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDspStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDspStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDspStateValue = unsafe.Sizeof([1]C.vorbis_dsp_state{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSInfo transforms a sliced Go data structure into plain C format.
func unpackSInfo(x []Info) (unpacked *C.vorbis_info, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vorbis_info) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vorbis_info)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vorbis_info)(h.Data)
	return
}

// allocPFloatMemory allocates memory for type *C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFloatValue = unsafe.Sizeof([1]*C.float{})

// unpackSSFloat32 transforms a sliced Go data structure into plain C format.
func unpackSSFloat32(x [][]float32) (unpacked **C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.float)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.float)(h.Data)
	return
}

// packSInfo reads sliced Go data structure out from plain C format.
func packSInfo(v []Info, ptr0 *C.vorbis_info) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfInfoValue]C.vorbis_info)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSFloat32 reads sliced Go data structure out from plain C format.
func packSSFloat32(v [][]float32, ptr0 **C.float) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.float)(unsafe.Pointer(ptr0)))[i0]
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf2fab0d.Data = unsafe.Pointer(ptr1)
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DspState) Ref() *C.vorbis_dsp_state {
	if x == nil {
		return nil
	}
	return x.refde21b9b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DspState) Free() {
	if x != nil && x.allocsde21b9b1 != nil {
		x.allocsde21b9b1.(*cgoAllocMap).Free()
		x.refde21b9b1 = nil
	}
}

// NewDspStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDspStateRef(ref unsafe.Pointer) *DspState {
	if ref == nil {
		return nil
	}
	obj := new(DspState)
	obj.refde21b9b1 = (*C.vorbis_dsp_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DspState) PassRef() (*C.vorbis_dsp_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde21b9b1 != nil {
		return x.refde21b9b1, nil
	}
	memde21b9b1 := allocDspStateMemory(1)
	refde21b9b1 := (*C.vorbis_dsp_state)(memde21b9b1)
	allocsde21b9b1 := new(cgoAllocMap)
	allocsde21b9b1.Add(memde21b9b1)

	var canalysisp_allocs *cgoAllocMap
	refde21b9b1.analysisp, canalysisp_allocs = (C.int)(x.Analysisp), cgoAllocsUnknown
	allocsde21b9b1.Borrow(canalysisp_allocs)

	var cvi_allocs *cgoAllocMap
	refde21b9b1.vi, cvi_allocs = unpackSInfo(x.Vi)
	allocsde21b9b1.Borrow(cvi_allocs)

	var cpcm_allocs *cgoAllocMap
	refde21b9b1.pcm, cpcm_allocs = unpackSSFloat32(x.Pcm)
	allocsde21b9b1.Borrow(cpcm_allocs)

	var cpcmret_allocs *cgoAllocMap
	refde21b9b1.pcmret, cpcmret_allocs = unpackSSFloat32(x.Pcmret)
	allocsde21b9b1.Borrow(cpcmret_allocs)

	var cpcm_storage_allocs *cgoAllocMap
	refde21b9b1.pcm_storage, cpcm_storage_allocs = (C.int)(x.PcmStorage), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cpcm_storage_allocs)

	var cpcm_current_allocs *cgoAllocMap
	refde21b9b1.pcm_current, cpcm_current_allocs = (C.int)(x.PcmCurrent), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cpcm_current_allocs)

	var cpcm_returned_allocs *cgoAllocMap
	refde21b9b1.pcm_returned, cpcm_returned_allocs = (C.int)(x.PcmReturned), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cpcm_returned_allocs)

	var cpreextrapolate_allocs *cgoAllocMap
	refde21b9b1.preextrapolate, cpreextrapolate_allocs = (C.int)(x.Preextrapolate), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cpreextrapolate_allocs)

	var ceofflag_allocs *cgoAllocMap
	refde21b9b1.eofflag, ceofflag_allocs = (C.int)(x.Eofflag), cgoAllocsUnknown
	allocsde21b9b1.Borrow(ceofflag_allocs)

	var clW_allocs *cgoAllocMap
	refde21b9b1.lW, clW_allocs = (C.long)(x.Lw), cgoAllocsUnknown
	allocsde21b9b1.Borrow(clW_allocs)

	var cW_allocs *cgoAllocMap
	refde21b9b1.W, cW_allocs = (C.long)(x.W), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cW_allocs)

	var cnW_allocs *cgoAllocMap
	refde21b9b1.nW, cnW_allocs = (C.long)(x.Nw), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cnW_allocs)

	var ccenterW_allocs *cgoAllocMap
	refde21b9b1.centerW, ccenterW_allocs = (C.long)(x.Centerw), cgoAllocsUnknown
	allocsde21b9b1.Borrow(ccenterW_allocs)

	var cgranulepos_allocs *cgoAllocMap
	refde21b9b1.granulepos, cgranulepos_allocs = (C.ogg_int64_t)(x.Granulepos), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cgranulepos_allocs)

	var csequence_allocs *cgoAllocMap
	refde21b9b1.sequence, csequence_allocs = (C.ogg_int64_t)(x.Sequence), cgoAllocsUnknown
	allocsde21b9b1.Borrow(csequence_allocs)

	var cglue_bits_allocs *cgoAllocMap
	refde21b9b1.glue_bits, cglue_bits_allocs = (C.ogg_int64_t)(x.GlueBits), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cglue_bits_allocs)

	var ctime_bits_allocs *cgoAllocMap
	refde21b9b1.time_bits, ctime_bits_allocs = (C.ogg_int64_t)(x.TimeBits), cgoAllocsUnknown
	allocsde21b9b1.Borrow(ctime_bits_allocs)

	var cfloor_bits_allocs *cgoAllocMap
	refde21b9b1.floor_bits, cfloor_bits_allocs = (C.ogg_int64_t)(x.FloorBits), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cfloor_bits_allocs)

	var cres_bits_allocs *cgoAllocMap
	refde21b9b1.res_bits, cres_bits_allocs = (C.ogg_int64_t)(x.ResBits), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cres_bits_allocs)

	var cbackend_state_allocs *cgoAllocMap
	refde21b9b1.backend_state, cbackend_state_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.BackendState)), cgoAllocsUnknown
	allocsde21b9b1.Borrow(cbackend_state_allocs)

	x.refde21b9b1 = refde21b9b1
	x.allocsde21b9b1 = allocsde21b9b1
	return refde21b9b1, allocsde21b9b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DspState) PassValue() (C.vorbis_dsp_state, *cgoAllocMap) {
	if x.refde21b9b1 != nil {
		return *x.refde21b9b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DspState) Deref() {
	if x.refde21b9b1 == nil {
		return
	}
	x.Analysisp = (int32)(x.refde21b9b1.analysisp)
	packSInfo(x.Vi, x.refde21b9b1.vi)
	packSSFloat32(x.Pcm, x.refde21b9b1.pcm)
	packSSFloat32(x.Pcmret, x.refde21b9b1.pcmret)
	x.PcmStorage = (int32)(x.refde21b9b1.pcm_storage)
	x.PcmCurrent = (int32)(x.refde21b9b1.pcm_current)
	x.PcmReturned = (int32)(x.refde21b9b1.pcm_returned)
	x.Preextrapolate = (int32)(x.refde21b9b1.preextrapolate)
	x.Eofflag = (int32)(x.refde21b9b1.eofflag)
	x.Lw = (int)(x.refde21b9b1.lW)
	x.W = (int)(x.refde21b9b1.W)
	x.Nw = (int)(x.refde21b9b1.nW)
	x.Centerw = (int)(x.refde21b9b1.centerW)
	x.Granulepos = (OggInt64)(x.refde21b9b1.granulepos)
	x.Sequence = (OggInt64)(x.refde21b9b1.sequence)
	x.GlueBits = (OggInt64)(x.refde21b9b1.glue_bits)
	x.TimeBits = (OggInt64)(x.refde21b9b1.time_bits)
	x.FloorBits = (OggInt64)(x.refde21b9b1.floor_bits)
	x.ResBits = (OggInt64)(x.refde21b9b1.res_bits)
	x.BackendState = (unsafe.Pointer)(unsafe.Pointer(x.refde21b9b1.backend_state))
}

// allocBlockMemory allocates memory for type C.vorbis_block in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBlockValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBlockValue = unsafe.Sizeof([1]C.vorbis_block{})

// unpackSDspState transforms a sliced Go data structure into plain C format.
func unpackSDspState(x []DspState) (unpacked *C.vorbis_dsp_state, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vorbis_dsp_state) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDspStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vorbis_dsp_state)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vorbis_dsp_state)(h.Data)
	return
}

// packSDspState reads sliced Go data structure out from plain C format.
func packSDspState(v []DspState, ptr0 *C.vorbis_dsp_state) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDspStateValue]C.vorbis_dsp_state)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDspStateRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Block) Ref() *C.vorbis_block {
	if x == nil {
		return nil
	}
	return x.ref5962d739
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Block) Free() {
	if x != nil && x.allocs5962d739 != nil {
		x.allocs5962d739.(*cgoAllocMap).Free()
		x.ref5962d739 = nil
	}
}

// NewBlockRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBlockRef(ref unsafe.Pointer) *Block {
	if ref == nil {
		return nil
	}
	obj := new(Block)
	obj.ref5962d739 = (*C.vorbis_block)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Block) PassRef() (*C.vorbis_block, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5962d739 != nil {
		return x.ref5962d739, nil
	}
	mem5962d739 := allocBlockMemory(1)
	ref5962d739 := (*C.vorbis_block)(mem5962d739)
	allocs5962d739 := new(cgoAllocMap)
	allocs5962d739.Add(mem5962d739)

	var cpcm_allocs *cgoAllocMap
	ref5962d739.pcm, cpcm_allocs = unpackSSFloat32(x.Pcm)
	allocs5962d739.Borrow(cpcm_allocs)

	var clW_allocs *cgoAllocMap
	ref5962d739.lW, clW_allocs = (C.long)(x.Lw), cgoAllocsUnknown
	allocs5962d739.Borrow(clW_allocs)

	var cW_allocs *cgoAllocMap
	ref5962d739.W, cW_allocs = (C.long)(x.W), cgoAllocsUnknown
	allocs5962d739.Borrow(cW_allocs)

	var cnW_allocs *cgoAllocMap
	ref5962d739.nW, cnW_allocs = (C.long)(x.Nw), cgoAllocsUnknown
	allocs5962d739.Borrow(cnW_allocs)

	var cpcmend_allocs *cgoAllocMap
	ref5962d739.pcmend, cpcmend_allocs = (C.int)(x.Pcmend), cgoAllocsUnknown
	allocs5962d739.Borrow(cpcmend_allocs)

	var cmode_allocs *cgoAllocMap
	ref5962d739.mode, cmode_allocs = (C.int)(x.Mode), cgoAllocsUnknown
	allocs5962d739.Borrow(cmode_allocs)

	var ceofflag_allocs *cgoAllocMap
	ref5962d739.eofflag, ceofflag_allocs = (C.int)(x.Eofflag), cgoAllocsUnknown
	allocs5962d739.Borrow(ceofflag_allocs)

	var cgranulepos_allocs *cgoAllocMap
	ref5962d739.granulepos, cgranulepos_allocs = (C.ogg_int64_t)(x.Granulepos), cgoAllocsUnknown
	allocs5962d739.Borrow(cgranulepos_allocs)

	var csequence_allocs *cgoAllocMap
	ref5962d739.sequence, csequence_allocs = (C.ogg_int64_t)(x.Sequence), cgoAllocsUnknown
	allocs5962d739.Borrow(csequence_allocs)

	var cvd_allocs *cgoAllocMap
	ref5962d739.vd, cvd_allocs = unpackSDspState(x.Vd)
	allocs5962d739.Borrow(cvd_allocs)

	var clocalstore_allocs *cgoAllocMap
	ref5962d739.localstore, clocalstore_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Localstore)), cgoAllocsUnknown
	allocs5962d739.Borrow(clocalstore_allocs)

	var clocaltop_allocs *cgoAllocMap
	ref5962d739.localtop, clocaltop_allocs = (C.long)(x.Localtop), cgoAllocsUnknown
	allocs5962d739.Borrow(clocaltop_allocs)

	var clocalalloc_allocs *cgoAllocMap
	ref5962d739.localalloc, clocalalloc_allocs = (C.long)(x.Localalloc), cgoAllocsUnknown
	allocs5962d739.Borrow(clocalalloc_allocs)

	var ctotaluse_allocs *cgoAllocMap
	ref5962d739.totaluse, ctotaluse_allocs = (C.long)(x.Totaluse), cgoAllocsUnknown
	allocs5962d739.Borrow(ctotaluse_allocs)

	var cglue_bits_allocs *cgoAllocMap
	ref5962d739.glue_bits, cglue_bits_allocs = (C.long)(x.GlueBits), cgoAllocsUnknown
	allocs5962d739.Borrow(cglue_bits_allocs)

	var ctime_bits_allocs *cgoAllocMap
	ref5962d739.time_bits, ctime_bits_allocs = (C.long)(x.TimeBits), cgoAllocsUnknown
	allocs5962d739.Borrow(ctime_bits_allocs)

	var cfloor_bits_allocs *cgoAllocMap
	ref5962d739.floor_bits, cfloor_bits_allocs = (C.long)(x.FloorBits), cgoAllocsUnknown
	allocs5962d739.Borrow(cfloor_bits_allocs)

	var cres_bits_allocs *cgoAllocMap
	ref5962d739.res_bits, cres_bits_allocs = (C.long)(x.ResBits), cgoAllocsUnknown
	allocs5962d739.Borrow(cres_bits_allocs)

	var cinternal_allocs *cgoAllocMap
	ref5962d739.internal, cinternal_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Internal)), cgoAllocsUnknown
	allocs5962d739.Borrow(cinternal_allocs)

	x.ref5962d739 = ref5962d739
	x.allocs5962d739 = allocs5962d739
	return ref5962d739, allocs5962d739

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Block) PassValue() (C.vorbis_block, *cgoAllocMap) {
	if x.ref5962d739 != nil {
		return *x.ref5962d739, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Block) Deref() {
	if x.ref5962d739 == nil {
		return
	}
	packSSFloat32(x.Pcm, x.ref5962d739.pcm)
	x.Lw = (int)(x.ref5962d739.lW)
	x.W = (int)(x.ref5962d739.W)
	x.Nw = (int)(x.ref5962d739.nW)
	x.Pcmend = (int32)(x.ref5962d739.pcmend)
	x.Mode = (int32)(x.ref5962d739.mode)
	x.Eofflag = (int32)(x.ref5962d739.eofflag)
	x.Granulepos = (OggInt64)(x.ref5962d739.granulepos)
	x.Sequence = (OggInt64)(x.ref5962d739.sequence)
	packSDspState(x.Vd, x.ref5962d739.vd)
	x.Localstore = (unsafe.Pointer)(unsafe.Pointer(x.ref5962d739.localstore))
	x.Localtop = (int)(x.ref5962d739.localtop)
	x.Localalloc = (int)(x.ref5962d739.localalloc)
	x.Totaluse = (int)(x.ref5962d739.totaluse)
	x.GlueBits = (int)(x.ref5962d739.glue_bits)
	x.TimeBits = (int)(x.ref5962d739.time_bits)
	x.FloorBits = (int)(x.ref5962d739.floor_bits)
	x.ResBits = (int)(x.ref5962d739.res_bits)
	x.Internal = (unsafe.Pointer)(unsafe.Pointer(x.ref5962d739.internal))
}

// allocCommentMemory allocates memory for type C.vorbis_comment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommentValue = unsafe.Sizeof([1]C.vorbis_comment{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf3b8dbd.Data = unsafe.Pointer(ptr1)
		hxf3b8dbd.Cap = 0x7fffffff
		// hxf3b8dbd.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Comment) Ref() *C.vorbis_comment {
	if x == nil {
		return nil
	}
	return x.ref4b9e021f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Comment) Free() {
	if x != nil && x.allocs4b9e021f != nil {
		x.allocs4b9e021f.(*cgoAllocMap).Free()
		x.ref4b9e021f = nil
	}
}

// NewCommentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommentRef(ref unsafe.Pointer) *Comment {
	if ref == nil {
		return nil
	}
	obj := new(Comment)
	obj.ref4b9e021f = (*C.vorbis_comment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Comment) PassRef() (*C.vorbis_comment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b9e021f != nil {
		return x.ref4b9e021f, nil
	}
	mem4b9e021f := allocCommentMemory(1)
	ref4b9e021f := (*C.vorbis_comment)(mem4b9e021f)
	allocs4b9e021f := new(cgoAllocMap)
	allocs4b9e021f.Add(mem4b9e021f)

	var cuser_comments_allocs *cgoAllocMap
	ref4b9e021f.user_comments, cuser_comments_allocs = unpackSSByte(x.UserComments)
	allocs4b9e021f.Borrow(cuser_comments_allocs)

	var ccomment_lengths_allocs *cgoAllocMap
	ref4b9e021f.comment_lengths, ccomment_lengths_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.CommentLengths)).Data)), cgoAllocsUnknown
	allocs4b9e021f.Borrow(ccomment_lengths_allocs)

	var ccomments_allocs *cgoAllocMap
	ref4b9e021f.comments, ccomments_allocs = (C.int)(x.Comments), cgoAllocsUnknown
	allocs4b9e021f.Borrow(ccomments_allocs)

	var cvendor_allocs *cgoAllocMap
	ref4b9e021f.vendor, cvendor_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Vendor)).Data)), cgoAllocsUnknown
	allocs4b9e021f.Borrow(cvendor_allocs)

	x.ref4b9e021f = ref4b9e021f
	x.allocs4b9e021f = allocs4b9e021f
	return ref4b9e021f, allocs4b9e021f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Comment) PassValue() (C.vorbis_comment, *cgoAllocMap) {
	if x.ref4b9e021f != nil {
		return *x.ref4b9e021f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Comment) Deref() {
	if x.ref4b9e021f == nil {
		return
	}
	packSSByte(x.UserComments, x.ref4b9e021f.user_comments)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.CommentLengths))
	hxf7a6dff.Data = unsafe.Pointer(x.ref4b9e021f.comment_lengths)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

	x.Comments = (int32)(x.ref4b9e021f.comments)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.Vendor))
	hxfe48d67.Data = unsafe.Pointer(x.ref4b9e021f.vendor)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// allocPPFloatMemory allocates memory for type **C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPFloatValue = unsafe.Sizeof([1]**C.float{})

// unpackArgSSSFloat32 transforms a sliced Go data structure into plain C format.
func unpackArgSSSFloat32(x [][][]float32) (unpacked ***C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(****C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]**C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPFloatMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]*C.float)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			h := (*sliceHeader)(unsafe.Pointer(&x[i0][i1]))
			v1[i1] = (*C.float)(h.Data)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (**C.float)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (***C.float)(h.Data)
	return
}

// packSSSFloat32 reads sliced Go data structure out from plain C format.
func packSSSFloat32(v [][][]float32, ptr0 ***C.float) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]**C.float)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPtr]*C.float)(unsafe.Pointer(ptr1)))[i1]
			hxf4171bf := (*sliceHeader)(unsafe.Pointer(&v[i0][i1]))
			hxf4171bf.Data = unsafe.Pointer(ptr2)
			hxf4171bf.Cap = 0x7fffffff
			// hxf4171bf.Len = ?
		}
	}
}
