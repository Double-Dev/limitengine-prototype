// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 07 Jul 2020 19:05:22 MDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vorbis

/*
#include "stb_vorbis.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocStb_vorbis_allocMemory allocates memory for type C.stb_vorbis_alloc in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStb_vorbis_allocMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStb_vorbis_allocValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStb_vorbis_allocValue = unsafe.Sizeof([1]C.stb_vorbis_alloc{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *stb_vorbis_alloc) Ref() *C.stb_vorbis_alloc {
	if x == nil {
		return nil
	}
	return x.ref10434850
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *stb_vorbis_alloc) Free() {
	if x != nil && x.allocs10434850 != nil {
		x.allocs10434850.(*cgoAllocMap).Free()
		x.ref10434850 = nil
	}
}

// Newstb_vorbis_allocRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newstb_vorbis_allocRef(ref unsafe.Pointer) *stb_vorbis_alloc {
	if ref == nil {
		return nil
	}
	obj := new(stb_vorbis_alloc)
	obj.ref10434850 = (*C.stb_vorbis_alloc)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *stb_vorbis_alloc) PassRef() (*C.stb_vorbis_alloc, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref10434850 != nil {
		return x.ref10434850, nil
	}
	mem10434850 := allocStb_vorbis_allocMemory(1)
	ref10434850 := (*C.stb_vorbis_alloc)(mem10434850)
	allocs10434850 := new(cgoAllocMap)
	allocs10434850.Add(mem10434850)

	var calloc_buffer_allocs *cgoAllocMap
	ref10434850.alloc_buffer, calloc_buffer_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.alloc_buffer)).Data)), cgoAllocsUnknown
	allocs10434850.Borrow(calloc_buffer_allocs)

	var calloc_buffer_length_in_bytes_allocs *cgoAllocMap
	ref10434850.alloc_buffer_length_in_bytes, calloc_buffer_length_in_bytes_allocs = (C.int)(x.alloc_buffer_length_in_bytes), cgoAllocsUnknown
	allocs10434850.Borrow(calloc_buffer_length_in_bytes_allocs)

	x.ref10434850 = ref10434850
	x.allocs10434850 = allocs10434850
	return ref10434850, allocs10434850

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x stb_vorbis_alloc) PassValue() (C.stb_vorbis_alloc, *cgoAllocMap) {
	if x.ref10434850 != nil {
		return *x.ref10434850, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *stb_vorbis_alloc) Deref() {
	if x.ref10434850 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.alloc_buffer))
	hxfc4425b.Data = unsafe.Pointer(x.ref10434850.alloc_buffer)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.alloc_buffer_length_in_bytes = (int32)(x.ref10434850.alloc_buffer_length_in_bytes)
}

// Ref returns a reference to C object as it is.
func (x *stb_vorbis) Ref() *C.stb_vorbis {
	if x == nil {
		return nil
	}
	return (*C.stb_vorbis)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *stb_vorbis) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// Newstb_vorbisRef converts the C object reference into a raw struct reference without wrapping.
func Newstb_vorbisRef(ref unsafe.Pointer) *stb_vorbis {
	return (*stb_vorbis)(ref)
}

// Newstb_vorbis allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func Newstb_vorbis() *stb_vorbis {
	return (*stb_vorbis)(allocStb_vorbisMemory(1))
}

// allocStb_vorbisMemory allocates memory for type C.stb_vorbis in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStb_vorbisMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStb_vorbisValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStb_vorbisValue = unsafe.Sizeof([1]C.stb_vorbis{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *stb_vorbis) PassRef() *C.stb_vorbis {
	if x == nil {
		x = (*stb_vorbis)(allocStb_vorbisMemory(1))
	}
	return (*C.stb_vorbis)(unsafe.Pointer(x))
}

// allocStb_vorbis_infoMemory allocates memory for type C.stb_vorbis_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStb_vorbis_infoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStb_vorbis_infoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStb_vorbis_infoValue = unsafe.Sizeof([1]C.stb_vorbis_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *stb_vorbis_info) Ref() *C.stb_vorbis_info {
	if x == nil {
		return nil
	}
	return x.refaa876ed4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *stb_vorbis_info) Free() {
	if x != nil && x.allocsaa876ed4 != nil {
		x.allocsaa876ed4.(*cgoAllocMap).Free()
		x.refaa876ed4 = nil
	}
}

// Newstb_vorbis_infoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newstb_vorbis_infoRef(ref unsafe.Pointer) *stb_vorbis_info {
	if ref == nil {
		return nil
	}
	obj := new(stb_vorbis_info)
	obj.refaa876ed4 = (*C.stb_vorbis_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *stb_vorbis_info) PassRef() (*C.stb_vorbis_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa876ed4 != nil {
		return x.refaa876ed4, nil
	}
	memaa876ed4 := allocStb_vorbis_infoMemory(1)
	refaa876ed4 := (*C.stb_vorbis_info)(memaa876ed4)
	allocsaa876ed4 := new(cgoAllocMap)
	allocsaa876ed4.Add(memaa876ed4)

	var csample_rate_allocs *cgoAllocMap
	refaa876ed4.sample_rate, csample_rate_allocs = (C.uint)(x.sample_rate), cgoAllocsUnknown
	allocsaa876ed4.Borrow(csample_rate_allocs)

	var cchannels_allocs *cgoAllocMap
	refaa876ed4.channels, cchannels_allocs = (C.int)(x.channels), cgoAllocsUnknown
	allocsaa876ed4.Borrow(cchannels_allocs)

	var csetup_memory_required_allocs *cgoAllocMap
	refaa876ed4.setup_memory_required, csetup_memory_required_allocs = (C.uint)(x.setup_memory_required), cgoAllocsUnknown
	allocsaa876ed4.Borrow(csetup_memory_required_allocs)

	var csetup_temp_memory_required_allocs *cgoAllocMap
	refaa876ed4.setup_temp_memory_required, csetup_temp_memory_required_allocs = (C.uint)(x.setup_temp_memory_required), cgoAllocsUnknown
	allocsaa876ed4.Borrow(csetup_temp_memory_required_allocs)

	var ctemp_memory_required_allocs *cgoAllocMap
	refaa876ed4.temp_memory_required, ctemp_memory_required_allocs = (C.uint)(x.temp_memory_required), cgoAllocsUnknown
	allocsaa876ed4.Borrow(ctemp_memory_required_allocs)

	var cmax_frame_size_allocs *cgoAllocMap
	refaa876ed4.max_frame_size, cmax_frame_size_allocs = (C.int)(x.max_frame_size), cgoAllocsUnknown
	allocsaa876ed4.Borrow(cmax_frame_size_allocs)

	x.refaa876ed4 = refaa876ed4
	x.allocsaa876ed4 = allocsaa876ed4
	return refaa876ed4, allocsaa876ed4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x stb_vorbis_info) PassValue() (C.stb_vorbis_info, *cgoAllocMap) {
	if x.refaa876ed4 != nil {
		return *x.refaa876ed4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *stb_vorbis_info) Deref() {
	if x.refaa876ed4 == nil {
		return
	}
	x.sample_rate = (uint32)(x.refaa876ed4.sample_rate)
	x.channels = (int32)(x.refaa876ed4.channels)
	x.setup_memory_required = (uint32)(x.refaa876ed4.setup_memory_required)
	x.setup_temp_memory_required = (uint32)(x.refaa876ed4.setup_temp_memory_required)
	x.temp_memory_required = (uint32)(x.refaa876ed4.temp_memory_required)
	x.max_frame_size = (int32)(x.refaa876ed4.max_frame_size)
}

// allocStb_vorbis_commentMemory allocates memory for type C.stb_vorbis_comment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStb_vorbis_commentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStb_vorbis_commentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStb_vorbis_commentValue = unsafe.Sizeof([1]C.stb_vorbis_comment{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff2234b.Data = unsafe.Pointer(ptr1)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *stb_vorbis_comment) Ref() *C.stb_vorbis_comment {
	if x == nil {
		return nil
	}
	return x.refad9c9b48
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *stb_vorbis_comment) Free() {
	if x != nil && x.allocsad9c9b48 != nil {
		x.allocsad9c9b48.(*cgoAllocMap).Free()
		x.refad9c9b48 = nil
	}
}

// Newstb_vorbis_commentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newstb_vorbis_commentRef(ref unsafe.Pointer) *stb_vorbis_comment {
	if ref == nil {
		return nil
	}
	obj := new(stb_vorbis_comment)
	obj.refad9c9b48 = (*C.stb_vorbis_comment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *stb_vorbis_comment) PassRef() (*C.stb_vorbis_comment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refad9c9b48 != nil {
		return x.refad9c9b48, nil
	}
	memad9c9b48 := allocStb_vorbis_commentMemory(1)
	refad9c9b48 := (*C.stb_vorbis_comment)(memad9c9b48)
	allocsad9c9b48 := new(cgoAllocMap)
	allocsad9c9b48.Add(memad9c9b48)

	var cvendor_allocs *cgoAllocMap
	refad9c9b48.vendor, cvendor_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.vendor)).Data)), cgoAllocsUnknown
	allocsad9c9b48.Borrow(cvendor_allocs)

	var ccomment_list_length_allocs *cgoAllocMap
	refad9c9b48.comment_list_length, ccomment_list_length_allocs = (C.int)(x.comment_list_length), cgoAllocsUnknown
	allocsad9c9b48.Borrow(ccomment_list_length_allocs)

	var ccomment_list_allocs *cgoAllocMap
	refad9c9b48.comment_list, ccomment_list_allocs = unpackSSByte(x.comment_list)
	allocsad9c9b48.Borrow(ccomment_list_allocs)

	x.refad9c9b48 = refad9c9b48
	x.allocsad9c9b48 = allocsad9c9b48
	return refad9c9b48, allocsad9c9b48

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x stb_vorbis_comment) PassValue() (C.stb_vorbis_comment, *cgoAllocMap) {
	if x.refad9c9b48 != nil {
		return *x.refad9c9b48, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *stb_vorbis_comment) Deref() {
	if x.refad9c9b48 == nil {
		return
	}
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.vendor))
	hxf95e7c8.Data = unsafe.Pointer(x.refad9c9b48.vendor)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.comment_list_length = (int32)(x.refad9c9b48.comment_list_length)
	packSSByte(x.comment_list, x.refad9c9b48.comment_list)
}

// allocFileMemory allocates memory for type C.FILE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFileValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFileValue = unsafe.Sizeof([1]C.FILE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *file) Ref() *C.FILE {
	if x == nil {
		return nil
	}
	return x.refba0adba4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *file) Free() {
	if x != nil && x.allocsba0adba4 != nil {
		x.allocsba0adba4.(*cgoAllocMap).Free()
		x.refba0adba4 = nil
	}
}

// NewfileRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewfileRef(ref unsafe.Pointer) *file {
	if ref == nil {
		return nil
	}
	obj := new(file)
	obj.refba0adba4 = (*C.FILE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
// func (x *file) PassRef() (*C.FILE, *cgoAllocMap) {
// 	if x == nil {
// 		return nil, nil
// 	} else if x.refba0adba4 != nil {
// 		return x.refba0adba4, nil
// 	}
// 	memba0adba4 := allocFileMemory(1)
// 	refba0adba4 := (*C.FILE)(memba0adba4)
// 	allocsba0adba4 := new(cgoAllocMap)
// 	allocsba0adba4.Add(memba0adba4)

// 	var c_flags_allocs *cgoAllocMap
// 	refba0adba4._flags, c_flags_allocs = (C.int)(x._flags), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_flags_allocs)

// 	var c_IO_read_ptr_allocs *cgoAllocMap
// 	refba0adba4._IO_read_ptr, c_IO_read_ptr_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_read_ptr)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_read_ptr_allocs)

// 	var c_IO_read_end_allocs *cgoAllocMap
// 	refba0adba4._IO_read_end, c_IO_read_end_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_read_end)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_read_end_allocs)

// 	var c_IO_read_base_allocs *cgoAllocMap
// 	refba0adba4._IO_read_base, c_IO_read_base_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_read_base)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_read_base_allocs)

// 	var c_IO_write_base_allocs *cgoAllocMap
// 	refba0adba4._IO_write_base, c_IO_write_base_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_write_base)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_write_base_allocs)

// 	var c_IO_write_ptr_allocs *cgoAllocMap
// 	refba0adba4._IO_write_ptr, c_IO_write_ptr_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_write_ptr)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_write_ptr_allocs)

// 	var c_IO_write_end_allocs *cgoAllocMap
// 	refba0adba4._IO_write_end, c_IO_write_end_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_write_end)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_write_end_allocs)

// 	var c_IO_buf_base_allocs *cgoAllocMap
// 	refba0adba4._IO_buf_base, c_IO_buf_base_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_buf_base)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_buf_base_allocs)

// 	var c_IO_buf_end_allocs *cgoAllocMap
// 	refba0adba4._IO_buf_end, c_IO_buf_end_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_buf_end)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_buf_end_allocs)

// 	var c_IO_save_base_allocs *cgoAllocMap
// 	refba0adba4._IO_save_base, c_IO_save_base_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_save_base)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_save_base_allocs)

// 	var c_IO_backup_base_allocs *cgoAllocMap
// 	refba0adba4._IO_backup_base, c_IO_backup_base_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_backup_base)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_backup_base_allocs)

// 	var c_IO_save_end_allocs *cgoAllocMap
// 	refba0adba4._IO_save_end, c_IO_save_end_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x._io_save_end)).Data)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_IO_save_end_allocs)

// 	var c_fileno_allocs *cgoAllocMap
// 	refba0adba4._fileno, c_fileno_allocs = (C.int)(x._fileno), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_fileno_allocs)

// 	var c_flags2_allocs *cgoAllocMap
// 	refba0adba4._flags2, c_flags2_allocs = (C.int)(x._flags2), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_flags2_allocs)

// 	var c_old_offset_allocs *cgoAllocMap
// 	refba0adba4._old_offset, c_old_offset_allocs = (x._old_offset), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_old_offset_allocs)

// 	var c_cur_column_allocs *cgoAllocMap
// 	refba0adba4._cur_column, c_cur_column_allocs = (C.ushort)(x._cur_column), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_cur_column_allocs)

// 	var c_vtable_offset_allocs *cgoAllocMap
// 	refba0adba4._vtable_offset, c_vtable_offset_allocs = (C.schar)(x._vtable_offset), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_vtable_offset_allocs)

// 	var c_shortbuf_allocs *cgoAllocMap
// 	refba0adba4._shortbuf, c_shortbuf_allocs = *(*[1]C.char)(unsafe.Pointer(&x._shortbuf)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_shortbuf_allocs)

// 	var c_lock_allocs *cgoAllocMap
// 	refba0adba4._lock, c_lock_allocs = *(unsafe.Pointer(&x._lock)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_lock_allocs)

// 	var c_offset_allocs *cgoAllocMap
// 	refba0adba4._offset, c_offset_allocs = (x._offset), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_offset_allocs)

// 	var c_freeres_buf_allocs *cgoAllocMap
// 	refba0adba4._freeres_buf, c_freeres_buf_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x._freeres_buf)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_freeres_buf_allocs)

// 	var c__pad5_allocs *cgoAllocMap
// 	refba0adba4.__pad5, c__pad5_allocs = (C.size_t)(x.__pad5), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c__pad5_allocs)

// 	var c_mode_allocs *cgoAllocMap
// 	refba0adba4._mode, c_mode_allocs = (C.int)(x._mode), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_mode_allocs)

// 	var c_unused2_allocs *cgoAllocMap
// 	refba0adba4._unused2, c_unused2_allocs = *(*[20]C.char)(unsafe.Pointer(&x._unused2)), cgoAllocsUnknown
// 	allocsba0adba4.Borrow(c_unused2_allocs)

// 	x.refba0adba4 = refba0adba4
// 	x.allocsba0adba4 = allocsba0adba4
// 	return refba0adba4, allocsba0adba4

// }

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
// func (x file) PassValue() (C.FILE, *cgoAllocMap) {
// 	if x.refba0adba4 != nil {
// 		return *x.refba0adba4, nil
// 	}
// 	// ref, allocs := PassRef(x)
// 	return *ref, allocs
// }

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
// func (x *file) Deref() {
// 	if x.refba0adba4 == nil {
// 		return
// 	}
// 	x._flags = (int32)(x.refba0adba4._flags)
// 	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x._io_read_ptr))
// 	hxff73280.Data = unsafe.Pointer(x.refba0adba4._IO_read_ptr)
// 	hxff73280.Cap = 0x7fffffff
// 	// hxff73280.Len = ?

// 	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x._io_read_end))
// 	hxfa9955c.Data = unsafe.Pointer(x.refba0adba4._IO_read_end)
// 	hxfa9955c.Cap = 0x7fffffff
// 	// hxfa9955c.Len = ?

// 	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x._io_read_base))
// 	hxfa3f05c.Data = unsafe.Pointer(x.refba0adba4._IO_read_base)
// 	hxfa3f05c.Cap = 0x7fffffff
// 	// hxfa3f05c.Len = ?

// 	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x._io_write_base))
// 	hxf0d18b7.Data = unsafe.Pointer(x.refba0adba4._IO_write_base)
// 	hxf0d18b7.Cap = 0x7fffffff
// 	// hxf0d18b7.Len = ?

// 	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x._io_write_ptr))
// 	hxf2fab0d.Data = unsafe.Pointer(x.refba0adba4._IO_write_ptr)
// 	hxf2fab0d.Cap = 0x7fffffff
// 	// hxf2fab0d.Len = ?

// 	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x._io_write_end))
// 	hxf69fe70.Data = unsafe.Pointer(x.refba0adba4._IO_write_end)
// 	hxf69fe70.Cap = 0x7fffffff
// 	// hxf69fe70.Len = ?

// 	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x._io_buf_base))
// 	hxf65bf54.Data = unsafe.Pointer(x.refba0adba4._IO_buf_base)
// 	hxf65bf54.Cap = 0x7fffffff
// 	// hxf65bf54.Len = ?

// 	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x._io_buf_end))
// 	hxf3b8dbd.Data = unsafe.Pointer(x.refba0adba4._IO_buf_end)
// 	hxf3b8dbd.Cap = 0x7fffffff
// 	// hxf3b8dbd.Len = ?

// 	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x._io_save_base))
// 	hxf7a6dff.Data = unsafe.Pointer(x.refba0adba4._IO_save_base)
// 	hxf7a6dff.Cap = 0x7fffffff
// 	// hxf7a6dff.Len = ?

// 	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x._io_backup_base))
// 	hxfe48d67.Data = unsafe.Pointer(x.refba0adba4._IO_backup_base)
// 	hxfe48d67.Cap = 0x7fffffff
// 	// hxfe48d67.Len = ?

// 	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x._io_save_end))
// 	hxf4171bf.Data = unsafe.Pointer(x.refba0adba4._IO_save_end)
// 	hxf4171bf.Cap = 0x7fffffff
// 	// hxf4171bf.Len = ?

// 	x._fileno = (int32)(x.refba0adba4._fileno)
// 	x._flags2 = (int32)(x.refba0adba4._flags2)
// 	x._old_offset = (int)(x.refba0adba4._old_offset)
// 	x._cur_column = (uint16)(x.refba0adba4._cur_column)
// 	x._vtable_offset = (int8)(x.refba0adba4._vtable_offset)
// 	x._shortbuf = *(*[1]byte)(unsafe.Pointer(&x.refba0adba4._shortbuf))
// 	x._lock = (unsafe.Pointer)(unsafe.Pointer(x.refba0adba4._lock))
// 	x._offset = (int)(x.refba0adba4._offset)
// 	x._freeres_buf = (unsafe.Pointer)(unsafe.Pointer(x.refba0adba4._freeres_buf))
// 	x.__pad5 = (uint)(x.refba0adba4.__pad5)
// 	x._mode = (int32)(x.refba0adba4._mode)
// 	x._unused2 = *(*[20]byte)(unsafe.Pointer(&x.refba0adba4._unused2))
// }

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// unpackArgSStb_vorbis_alloc transforms a sliced Go data structure into plain C format.
func unpackArgSStb_vorbis_alloc(x []stb_vorbis_alloc) (unpacked *C.stb_vorbis_alloc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.stb_vorbis_alloc) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStb_vorbis_allocMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.stb_vorbis_alloc)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.stb_vorbis_alloc)(h.Data)
	return
}

// packSStb_vorbis_alloc reads sliced Go data structure out from plain C format.
func packSStb_vorbis_alloc(v []stb_vorbis_alloc, ptr0 *C.stb_vorbis_alloc) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStb_vorbis_allocValue]C.stb_vorbis_alloc)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *Newstb_vorbis_allocRef(unsafe.Pointer(&ptr1))
	}
}

// allocPPFloatMemory allocates memory for type **C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPFloatValue = unsafe.Sizeof([1]**C.float{})

// allocPFloatMemory allocates memory for type *C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFloatValue = unsafe.Sizeof([1]*C.float{})

// unpackArgSSSFloat32 transforms a sliced Go data structure into plain C format.
func unpackArgSSSFloat32(x [][][]float32) (unpacked ***C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(****C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]**C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPFloatMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]*C.float)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			h := (*sliceHeader)(unsafe.Pointer(&x[i0][i1]))
			v1[i1] = (*C.float)(h.Data)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (**C.float)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (***C.float)(h.Data)
	return
}

// packSSSFloat32 reads sliced Go data structure out from plain C format.
func packSSSFloat32(v [][][]float32, ptr0 ***C.float) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]**C.float)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPtr]*C.float)(unsafe.Pointer(ptr1)))[i1]
			hxf058b18 := (*sliceHeader)(unsafe.Pointer(&v[i0][i1]))
			hxf058b18.Data = unsafe.Pointer(ptr2)
			hxf058b18.Cap = 0x7fffffff
			// hxf058b18.Len = ?
		}
	}
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// allocPShortMemory allocates memory for type *C.short in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPShortMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPShortValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPShortValue = unsafe.Sizeof([1]*C.short{})

// unpackArgSSInt16 transforms a sliced Go data structure into plain C format.
func unpackArgSSInt16(x [][]int16) (unpacked **C.short, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.short) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPShortMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.short)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.short)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.short)(h.Data)
	return
}

// packSSInt16 reads sliced Go data structure out from plain C format.
func packSSInt16(v [][]int16, ptr0 **C.short) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.short)(unsafe.Pointer(ptr0)))[i0]
		hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff6bc57.Data = unsafe.Pointer(ptr1)
		hxff6bc57.Cap = 0x7fffffff
		// hxff6bc57.Len = ?
	}
}

// unpackArgSFile transforms a sliced Go data structure into plain C format.
func unpackArgSFile(x []file) (unpacked *C.FILE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.FILE) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFileMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.FILE)(unsafe.Pointer(h0))
	// for i0 := range x {
	// 	allocs0 := new(cgoAllocMap)
	// 	v0[i0], allocs0 = PassValue(x[i0])
	// 	allocs.Borrow(allocs0)
	// }
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.FILE)(h.Data)
	return
}

// packSFile reads sliced Go data structure out from plain C format.
func packSFile(v []file, ptr0 *C.FILE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFileValue]C.FILE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewfileRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSFloat32 transforms a sliced Go data structure into plain C format.
func unpackArgSSFloat32(x [][]float32) (unpacked **C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.float)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.float)(h.Data)
	return
}

// packSSFloat32 reads sliced Go data structure out from plain C format.
func packSSFloat32(v [][]float32, ptr0 **C.float) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.float)(unsafe.Pointer(ptr0)))[i0]
		hxf04b15b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf04b15b.Data = unsafe.Pointer(ptr1)
		hxf04b15b.Cap = 0x7fffffff
		// hxf04b15b.Len = ?
	}
}
